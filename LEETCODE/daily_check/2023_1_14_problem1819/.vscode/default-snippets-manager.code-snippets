{
	"latex_frame": {
		"prefix": "latex_frame",
		"description": "latex_frame",
		"scope": "latex",
		"body": [
			"\\documentclass[12pt]{ctexart}\r",
			"\r",
			"\\usepackage{amsmath}\r",
			"\\usepackage{mathabx} %添加证毕符号\r",
			"\\usepackage{cases}\r",
			"\r",
			"\\begin{document}\r",
			"\r",
			"\\title{1819. 序列中不同最大公约数数目 解析}\r",
			"\\author{张翼翔\\thanks{E-mail:21371055@buaa.edu.cn}}\r",
			"\\date{2023/1/14}\r",
			"\r",
			"\\maketitle\r",
			"\r",
			"\\section{方法一: 枚举}\r",
			"\r",
			"\\subsection{思路与算法}\r",
			"题目要求找到所有非空子序列中不同的最大公约数的数目, 我们可以尝试枚举所有可能的最大公约数. 假设 $p$ 为一个序列 $A = [a_0, a_1, \\cdots, a_k]$ 的最大公约数, 令 $a_i = ci \\times p$, 则序列即为 $A = [c_0 \\times p, c_1 \\times p, c_2 \\times p, \\cdots, c_k times p]$, 根据最大公约数的性质可知此时 $gcd(a_0, a_1, a_2, \\cdots,  a_k) = p$, 则可以推出 $gcd(c_0, c_1, c_2, \\cdots, c_k) = 1$. 此时我们在序列 $A$ 中添加 $p$ 的任意倍数 $a_{k + 1} = c_{k + 1} \\times p$ 时, 则序列 $A$ 的最大公约数依然为 $p$, 即此时 $gcd(a_0, a_1, a_2, \\cdots, a_k, a_{k + 1}) = p$.\r",
			"\r",
			"根据以上推论我们可以得出结论, 如果 $x$ 为数组 $nums$ 中的某个序列的最大公约数, 则数组中所有能够被 $x$ 整除的元素构成的最大公约数一定为 $x$. 这样的数我们也称之为 \\textbf{基本的}. 存在以 $x$为最大公约数的充分必要条件就是:\r",
			"\\begin{equation}\r",
			"    \\text{对于} \\forall m \\forall x ((m \\in [1, \\max (nums)] \\to m \\equiv 0 (\\bmod\\ x)) \\to (m \\geqslant y)). \\label{subsec:eq1}\r",
			"\\end{equation}\r",
			"\r",
			"根据上述结论, 我们可以枚举所有可能的最大公约数 $x$, 其中 $x \\in [1, \\max{(nums)}]$, 然后对数组中所有可以整除 $x$ 的元素求最大公约数, 判断最后求出的最大公约数是否等于 $x$ 即可. 如果等于, 说明这些数恰好以 $x$ 为最大公约数, 则 $ans++$.否则还有比 $x$ 更大的公约数 $y$, $x$ 不是最大公约数.\r",
			"\r",
			"\\subsection{代码}\r",
			"\\begin{verbatim}\r",
			"  class Solution {\r",
			"    public:\r",
			"        int countDifferentSubsequenceGCDs(vector<int>& nums) {\r",
			"            int maxVal = 0;\r",
			"            int ans = 0;\r",
			"            for (vector<int>::iterator it\r",
			"          = nums.begin(); it != nums.end(); ++it)\r",
			"            {\r",
			"                maxVal = max(maxVal, (*it));\r",
			"            }\r",
			"            vector<bool> occured(maxVal + 2, false);\r",
			"            for (vector<int>::iterator it \r",
			"            = nums.begin(); it != nums.end(); ++it)\r",
			"            {\r",
			"                occured[(*it)] = true;\r",
			"            }\r",
			"            for (int i = 1; i <= maxVal; i++)\r",
			"            {\r",
			"                int gcdVal = 0;\r",
			"                for (int k = i; k <= \r",
			"                maxVal; k = k + i)\r",
			"                {\r",
			"                    if (occured[k])\r",
			"                    {\r",
			"                        if (gcdVal == 0)\r",
			"                        { \r",
			"                            gcdVal = k;\r",
			"                        }\r",
			"                        else\r",
			"                        {\r",
			"                            gcdVal = __gcd(gcdVal, k);\r",
			"                        }\r",
			"                    }\r",
			"                }\r",
			"                ans += (i == gcdVal);\r",
			"            }\r",
			"            return ans;\r",
			"        }\r",
			"        //O(n + maxVal log(maxVal))\r",
			"    };\r",
			"\\end{verbatim}\r",
			"\r",
			"\\subsection{复杂度分析}\r",
			"\\subsubsection{时间复杂度}\r",
			"$O(n + \\max{nums}\\log{(\\max{(nums)})})$, 其中 $n$ 表示数组的长度, $\\max(nums)$ 表示数组中的最大元素. 我们首先需要遍历一遍数组, 然后从 $1$ 到 $\\max{(nums)}$ 一次枚举每个可能的最大公约数(公式~\\eqref{subsec:eq1})\r",
			"\\subsubsection{空间复杂度}\r",
			"\r",
			"\\end{document}"
		]
	}
}